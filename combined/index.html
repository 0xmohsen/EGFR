<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Combined Calculator</title>
  <link rel="stylesheet" href="../assets/style.css"/>
</head>
<body>
  <div class="container">
    <div class="header"><h1>Combined calculator</h1><div class="muted">Static browser calculator</div></div>
  <div class="muted">
    This calculator computes the raw combined model output and applies Platt recalibration to show calibrated probability.
    It can auto-fill values pushed from Radiomics/Clinical.
  </div>

  <div class="card">
    <div id="status" class="muted">Loading model…</div>
    <div id="pushInfo" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <h3>Inputs</h3>
    <div id="inputs" class="grid"></div>
    <div class="rowbtn">
      <button id="btnCompute" disabled>Compute</button>
      <a class="btn secondary" href="../">Back</a>
      <button id="btnClear" disabled>Clear pushed values</button>
    </div>
  </div>

  <div class="card">
    <div class="result" id="probCalText">Calibrated EGFR+ probability: —</div>
    <div class="muted" id="probRawText">Raw EGFR+ probability: —</div>
    <div class="muted" id="lpText">LP (raw logit): —</div>
    <div class="muted" id="calText">Calibration: —</div>
  </div>

<script>
let MODEL=null;
let CAL=null;

function invlogit(x){ return 1/(1+Math.exp(-x)); }
function safeId(key){ return "k__"+btoa(unescape(encodeURIComponent(key))).replaceAll("=", "_"); }

function buildInputs(schema, coef){
  const root=document.getElementById("inputs");
  root.innerHTML="";

  const terms = Object.keys(coef).filter(k=>k!=="(Intercept)" && k!=="Intercept");

  // Order: schema-defined terms first (in that order), then the rest alphabetically
  const schemaKeys = schema ? Object.keys(schema) : [];
  const schemaSet = new Set(schemaKeys);
  const rest = terms.filter(t=>!schemaSet.has(t)).sort((a,b)=>a.localeCompare(b));

  const ordered = [...schemaKeys.filter(k=>terms.includes(k)), ...rest];

  for(const k of ordered){
    const spec = (schema && schema[k]) ? schema[k] : {type:"number", label:k, step:"any", value:0};
    const wrap=document.createElement("div");
    const lab=document.createElement("label"); lab.textContent=spec.label || k;
    wrap.appendChild(lab);
    const id=safeId(k);

    if(spec.type==="select"){
      const sel=document.createElement("select"); sel.id=id;
      for(const opt of (spec.options||[])){
        const o=document.createElement("option"); o.value=opt.value; o.textContent=opt.label; sel.appendChild(o);
      }
      wrap.appendChild(sel);
    }else{
      const inp=document.createElement("input");
      inp.type="number"; inp.step=spec.step ?? "any";
      if(spec.min!==undefined) inp.min=spec.min;
      if(spec.max!==undefined) inp.max=spec.max;
      inp.value=(spec.value!==undefined)?spec.value:0;
      inp.id=id;
      wrap.appendChild(inp);
    }
    root.appendChild(wrap);
  }
}

function setVal(term, value, schema){
  const spec = (schema && schema[term]) ? schema[term] : {type:"number"};
  const el=document.getElementById(safeId(term));
  if(!el) return;
  if(spec.type==="select"){ el.value=String(value); } else { el.value=value; }
}

function getVal(term, schema){
  const spec = (schema && schema[term]) ? schema[term] : {type:"number"};
  const el=document.getElementById(safeId(term));
  if(!el) return null;
  if(spec.type==="select"){ const v=Number(el.value); return Number.isFinite(v)?v:null; }
  const v=el.value; if(v===""||v===null||v===undefined) return null;
  const num=Number(v); return Number.isFinite(num)?num:null;
}

function compute(){
  const coef=MODEL.coef;
  const schema=MODEL.schema||{};
  let lp = Number(coef["(Intercept)"] ?? coef["Intercept"] ?? 0);
  const terms=Object.keys(coef).filter(k=>k!=="(Intercept)" && k!=="Intercept");
  for(const t of terms){
    const x=getVal(t, schema);
    if(x===null){ alert("Missing/invalid input for: "+t); return null; }
    lp += Number(coef[t]) * Number(x);
  }
  const p_raw=invlogit(lp);

  let p_cal=p_raw;
  let cal_desc="No calibration loaded; showing raw probability only.";
  if(CAL && typeof CAL.intercept==="number" && typeof CAL.slope==="number"){
    const lp_cal = CAL.intercept + CAL.slope * lp;
    p_cal = invlogit(lp_cal);
    cal_desc = "Platt recalibration on LP: p_cal = sigmoid(intercept + slope·LP).";
  }

  document.getElementById("probCalText").textContent="Calibrated EGFR+ probability: "+p_cal.toFixed(3);
  document.getElementById("probRawText").textContent="Raw EGFR+ probability: "+p_raw.toFixed(3);
  document.getElementById("lpText").textContent="LP (raw logit): "+lp.toFixed(3);
  document.getElementById("calText").textContent="Calibration: "+cal_desc;

  return {lp:lp, prob_raw:p_raw, prob_cal:p_cal};
}

function applyPush(){
  const schema=MODEL.schema||{};
  const raw = localStorage.getItem("egfr_push");
  if(!raw){ document.getElementById("pushInfo").textContent="No pushed values detected."; return; }
  try{
    const payload = JSON.parse(raw);
    const radTerm = MODEL.radscore_term || "RadScore";

    if(payload.source==="radiomics"){
      if(Object.prototype.hasOwnProperty.call(MODEL.coef, radTerm)){
        setVal(radTerm, payload.radscore_value, schema);
        document.getElementById("pushInfo").textContent =
          "Auto-filled " + radTerm + " from Radiomics (" + payload.radscore_mode + ").";
      }else{
        document.getElementById("pushInfo").textContent =
          "Radiomics pushed value found, but combined model has no '" + radTerm + "' term.";
      }
    }else if(payload.source==="clinical"){
      let n=0;
      for(const [k,v] of Object.entries(payload.inputs||{})){
        if(Object.prototype.hasOwnProperty.call(MODEL.coef, k)){
          setVal(k, v, schema);
          n += 1;
        }
      }
      document.getElementById("pushInfo").textContent =
        "Auto-filled " + n + " clinical variable(s) from Clinical model.";
    }else{
      document.getElementById("pushInfo").textContent="Pushed values found (unknown source).";
    }
  }catch(e){
    document.getElementById("pushInfo").textContent="Could not parse pushed values.";
  }
}

function clearPush(){
  localStorage.removeItem("egfr_push");
  document.getElementById("pushInfo").textContent="Cleared pushed values.";
}

async function init(){
  try{
    const res=await fetch("./combined_model_params.json", {cache:"no-store"});
    if(!res.ok) throw new Error("Cannot load combined_model_params.json");
    MODEL=await res.json();

    try{
      const r2=await fetch("./combined_calibration_params.json", {cache:"no-store"});
      if(r2.ok) CAL=await r2.json();
    }catch(e){ /* ignore */ }

    buildInputs(MODEL.schema||{}, MODEL.coef);
    applyPush();

    document.getElementById("status").textContent="Model loaded. Fill/verify inputs and compute.";
    document.getElementById("btnCompute").disabled=false;
    document.getElementById("btnClear").disabled=false;
    document.getElementById("btnCompute").onclick=compute;
    document.getElementById("btnClear").onclick=clearPush;

    if(CAL && typeof CAL.intercept==="number" && typeof CAL.slope==="number"){
      document.getElementById("calText").textContent =
        "Calibration loaded: intercept=" + CAL.intercept.toFixed(6) + ", slope=" + CAL.slope.toFixed(6) + ".";
    }
  }catch(e){
    document.getElementById("status").textContent="ERROR: "+e.message;
    console.error(e);
  }
}
init();
</script>
  </div>
</body>
</html>
