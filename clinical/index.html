<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Clinical Calculator</title>
  <link rel="stylesheet" href="../assets/style.css"/>
</head>
<body>
  <div class="container">
    <div class="header"><h1>Clinical calculator</h1><div class="muted">Static browser calculator</div></div>
  <div class="muted">
    This calculator computes the raw model output (logistic regression using log(OR) coefficients) and then applies
    Platt recalibration (intercept/slope) to display a calibrated probability.
  </div>

  <div class="card"><div id="status" class="muted">Loading model…</div></div>

  <div class="card">
    <h3>Inputs</h3>
    <div id="inputs" class="grid"></div>
    <div class="rowbtn">
      <button id="btnCompute" disabled>Compute</button>
      <button id="btnPush" disabled>Push to Combined</button>
      <a class="btn secondary" href="../">Back</a>
    </div>
    <div class="muted" style="margin-top:10px;">
      “Push to Combined” sends overlapping clinical variable values (not calibrated probability).
    </div>
  </div>

  <div class="card">
    <div class="result" id="probCalText">Calibrated EGFR+ probability: —</div>
    <div class="muted" id="probRawText">Raw EGFR+ probability: —</div>
    <div class="muted" id="lpText">LP (raw logit): —</div>
    <div class="muted" id="calText">Calibration: —</div>
  </div>

<script>
let MODEL=null;
let CAL=null;

function invlogit(x){ return 1/(1+Math.exp(-x)); }
function safeId(key){ return "k__"+btoa(unescape(encodeURIComponent(key))).replaceAll("=", "_"); }

function buildInputs(schema, coef){
  const root=document.getElementById("inputs");
  root.innerHTML="";

  const terms = Object.keys(coef).filter(k=>k!=="(Intercept)" && k!=="Intercept");

  // Order: schema-defined terms first (in that order), then the rest alphabetically
  const schemaKeys = schema ? Object.keys(schema) : [];
  const schemaSet = new Set(schemaKeys);
  const rest = terms.filter(t=>!schemaSet.has(t)).sort((a,b)=>a.localeCompare(b));

  const ordered = [...schemaKeys.filter(k=>terms.includes(k)), ...rest];

  for(const k of ordered){
    const spec = (schema && schema[k]) ? schema[k] : {type:"number", label:k, step:"any", value:0};
    const wrap=document.createElement("div");
    const lab=document.createElement("label"); lab.textContent=spec.label || k;
    wrap.appendChild(lab);
    const id=safeId(k);

    if(spec.type==="select"){
      const sel=document.createElement("select"); sel.id=id;
      for(const opt of (spec.options||[])){
        const o=document.createElement("option"); o.value=opt.value; o.textContent=opt.label; sel.appendChild(o);
      }
      wrap.appendChild(sel);
    }else{
      const inp=document.createElement("input");
      inp.type="number"; inp.step=spec.step ?? "any";
      if(spec.min!==undefined) inp.min=spec.min;
      if(spec.max!==undefined) inp.max=spec.max;
      inp.value=(spec.value!==undefined)?spec.value:0;
      inp.id=id;
      wrap.appendChild(inp);
    }
    root.appendChild(wrap);
  }
}

function getVal(k, spec){
  const el=document.getElementById(safeId(k));
  if(!el) return null;
  if(spec && spec.type==="select"){ const v=Number(el.value); return Number.isFinite(v)?v:null; }
  const v=el.value; if(v===""||v===null||v===undefined) return null;
  const num=Number(v); return Number.isFinite(num)?num:null;
}

function compute(){
  const coef=MODEL.coef;
  const schema=MODEL.schema||{};
  let lp = Number(coef["(Intercept)"] ?? coef["Intercept"] ?? 0);
  const terms=Object.keys(coef).filter(k=>k!=="(Intercept)" && k!=="Intercept");
  const inputs = {};
  for(const t of terms){
    const spec=schema[t] || {type:"number"};
    const x=getVal(t, spec);
    if(x===null){ alert("Missing/invalid input for: "+t); return null; }
    inputs[t]=x;
    lp += Number(coef[t]) * Number(x);
  }
  const p_raw=invlogit(lp);

  let p_cal=p_raw;
  let cal_desc="No calibration loaded; showing raw probability only.";
  if(CAL && typeof CAL.intercept==="number" && typeof CAL.slope==="number"){
    const lp_cal = CAL.intercept + CAL.slope * lp;
    p_cal = invlogit(lp_cal);
    cal_desc = "Platt recalibration on LP: p_cal = sigmoid(intercept + slope·LP).";
  }

  document.getElementById("probCalText").textContent="Calibrated EGFR+ probability: "+p_cal.toFixed(3);
  document.getElementById("probRawText").textContent="Raw EGFR+ probability: "+p_raw.toFixed(3);
  document.getElementById("lpText").textContent="LP (raw logit): "+lp.toFixed(3);
  document.getElementById("calText").textContent="Calibration: "+cal_desc;

  window.__LAST__ = {lp: lp, prob_raw:p_raw, prob_cal:p_cal, inputs: inputs};
  return window.__LAST__;
}

function pushToCombined(){
  if(!window.__LAST__){ alert("Compute first."); return; }
  const payload = {source:"clinical", timestamp:new Date().toISOString(), inputs: window.__LAST__.inputs};
  localStorage.setItem("egfr_push", JSON.stringify(payload));
  window.location.href="../combined/";
}

async function init(){
  try{
    const res=await fetch("./clinical_model_params.json", {cache:"no-store"});
    if(!res.ok) throw new Error("Cannot load clinical_model_params.json");
    MODEL=await res.json();

    try{
      const r2=await fetch("./clinical_calibration_params.json", {cache:"no-store"});
      if(r2.ok) CAL=await r2.json();
    }catch(e){ /* ignore */ }

    buildInputs(MODEL.schema||{}, MODEL.coef);
    document.getElementById("status").textContent="Model loaded. Fill inputs and compute.";
    document.getElementById("btnCompute").disabled=false;
    document.getElementById("btnPush").disabled=false;
    document.getElementById("btnCompute").onclick=compute;
    document.getElementById("btnPush").onclick=pushToCombined;

    if(CAL && typeof CAL.intercept==="number" && typeof CAL.slope==="number"){
      document.getElementById("calText").textContent =
        "Calibration loaded: intercept=" + CAL.intercept.toFixed(6) + ", slope=" + CAL.slope.toFixed(6) + ".";
    }
  }catch(e){
    document.getElementById("status").textContent="ERROR: "+e.message;
    console.error(e);
  }
}
init();
</script>
  </div>
</body>
</html>
